### 面向对象编程：将对象和类作为代码组织基本单元，来进行编程的一种编程范式或编程风格，不一定需要四大特性
### 面向过程编程：以过程和方法为 代码基本组织单元。 数据，方法分离
### 函数式编程：以无状态函数作为基本编程单元

Java为函数式编程引入：Stream类，Lambda表达式和函数接口的语法概念，只是Java编程范式的补充，在特殊领域发生特殊作用


**对比**

- 面向对象编程相比面向过程编程
    1. 代码更加具有复用性，扩展性，能够应对大规模复杂业务流程 
    2. 具有更加丰富的四大特性；
    3. 更加人性化，高级和智能。
- 面向过程编程方式更适合人类思考方式，数据和操作分离本身，数据本身操作不受限制

 
### 封装：类通过暴露有限的访问接口，授权外部仅能通过类提供的方式访问内部信息或数据。

封装的意义：

- 如果对类中属性访问不做限制，任何代码都可访问，虽然看起来灵活，但会带来不可控。某同学在不了解业务的情况下修改某个属性值，从而导致业务数据的不一致性
- 通过有限的方法暴露必要的操作，提高类的易用性。封装业务细节。

**实践**

- 滥用getter setter方法违背了封装的特性

### 抽象：隐藏方法具体实现，让调用者只关心方法提供了哪些功能

抽象的意义：

- 只关注功能点，不关注实现。
- 作为一个非常宽泛的设计思想。

**实践**

- 抽象方法定义的时候，要有抽象思维，不要暴漏太多的实现细节，例如：getImgFromAliyunOss应修改为getImg

### 继承：表达类之间 is-a 的关系

继承的意义：

- 代码复用
- 通过继承关联类，符合人类认知，设计上结构美感

**实践**

- 仅仅为了代码复用，硬生生的抽离出一个父类出来，会影响代码的可读性，可以尝试使用Utils类来解决（但是Utils类是一种面向过程的编程方法）

### 多态：子类替换父类，实际代码运行，调用子类方法实现

多态的意义：

- 多态解决的是代码的复用性和可扩展性



违反面向对象编程风格三种方式

- 滥用getter，setter方法，违反封装，暴露数据
- Constants，Utils类设计问题，职责不单一，类划分粗化；属性和方法如果能划分归并到其他业务类，更能增加内聚性和代码可复用性
- 数据和操作分开的贫血模型代码设计

### 抽象类和接口

**区别**

- 抽象类表达的是一种is-a的关系，抽象类更多的是为了解决代码复用的问题
    - 强制实现抽象方法；
    - 抽象是一种自下而上的思路,根据现有子类的代码重复，再抽离成上层父类
- 接口表示一种has-a的关系，接口更多的是为了解决解耦的问题，为了解决抽象而非代码复用的问题；先设计接口，再考虑具体实现
    - 而接口是一种自上而下的思路，先设计接口，在考虑接口实现的问题

**实践**

基于接口而非实现编程：接口实现相分离，封装不稳定的实现，暴露稳定的接口

**越抽象，越顶层，越脱离具体某一实现的设计，越能提高代码灵活性，越能应对未来需求变化。好的设计不仅能应对当下需求，还能满足未来变化**

### 组合还是继承

如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，我们就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使用组合来替代继承。

**实践**

继承层次过深，过于复杂影响代码可维护性。可借助组合，接口，委托来进行技术手段来达成多态，复用的目的。

### 贫血模型
只包含数据，不包含业务逻辑的类，叫做贫血模型。

**特点**

- 基于贫血模式的传统开发模式 重Service轻Domain；
- 一般我们贫血模式开发模式中，都是根据SQL驱动开发

### 充血模型
既包含数据，也包含业务逻辑的类，叫做充血模型。

**特点**

- 基于充血模式的开发模式，重Domain轻Service；
- 充血模型更加合适业务更加复杂的系统开发

### 为什么贫血模型还是比充血模型使用的多了

1. 我们一般开发系统业务比较简单，不必费尽心思设计充血模型，
2. 充血模型设计要比贫血模型更加有难度，一开始就要设计针对数据要暴露哪些操作，定义哪些业务逻辑。
3. 思维已固化，转型有成本

即使你对领域驱动设计再怎么熟悉，对业务不熟悉，也并不能作出合理的设计

### DDD领域模型
Servcie层还是进行1DB调用，2跨领域模型业务聚合，3；Domain领域层进行具体业务逻辑实现，


- Service负责跟Respository,非功能性，三方系统打交道，转化数据为领域模型，由领域模型完成业务逻辑，然后让Service调用Respositroy的方法完成数据的更新。领域模型应该保持独立性，不与其他层代码和框架进行耦合，使其更加复用
- Service负责跨领域模型业务聚合的作用，随着功能演进，Service也可独立出来成为一个领域
- Controller层负责接口暴露，Respostory负责数据库打交道，如果也是用充血模型会略显单薄。Respository的Entity和Controller的VO职责就只是数据的载体，生命周期有限，不应该包含业务逻辑。


### 接口鉴权
- 使用URL APPID,密码，时间戳拼接在一起，通过加密算法生成token，并将token，AppID，时间戳拼接在URL中，一并发送服务端。
- 服务端通过时间戳判断是否在失效时间内，若失效，鉴权失败，拒绝接口调用。
- 若在失效时间内，=取出AppID对应的密码，通过同样的token生成算法，生成另外的token。与客户端传来的token进行对比鉴权。


### 划分职责识别类

- 根据需求描述，把其中涉及的功能点，一个一个罗列出来，再根据功能点职责相近，操作相同属性，可否归为同一个类
- 定义类及其属性和方法
- 定义类与类之间的交互关系
- 将类组装起来并提供执行入口

## SOLID

### 单一职责原则(SRP)

- 一个类只完成一个职责，或功能；高内聚，低耦合，提高代码复用性，可读性，可维护性。

不同场景，不同阶段，对于类是否满足SRP有不同判断。但是实际出现情况：类中代码行数过多，方法，属性过多，依赖类过多，私有方法过多，比较难起名，大量方法操作某几个属性。这时，就应该进行类的拆分。


### 开闭原则（OCP）

添加一个新功能，应该在已有代码基础进行扩展（模块，类，方法，属性），而非修改。对扩展开放是为了应对变化，对修改关闭是为了保证已有代码稳定性。

- 并不是完全杜绝修改，最小修改代码代价完成新功能开发
- 同样代码修改下，粗粒度可被认定为修改；细粒度可被认为扩展

时刻要具备扩展，抽象，封装意识；写代码多花时间思考未来需求变更，代码结构设计，留好扩展点。做到最小代码改动，将新代码灵活插入扩展点

### 里式替换原则（LSP）

按照协议来设计；多态是面向对象编程的特性，里式替换是一种设计原则。

子类在设计的时候要遵守父类的行为约定。

### **多态和LSP区别**

多态是面向对象编程的一大**特性**，是一种代码实现思路；而LSP是一种设计原则，子类在替换父类时不改变原有程序逻辑，不破坏原有程序正确性

#### 怎么判断违反了LSP

拿父类的单元测试去测试子类的用例，如果失败则子类的设计实现可能违背LSP

**违约情况**

1. 子类违背父类声明要实现的功能
2. 子类违背父类对输入，输出，异常的约定
3. 子类违背父类注释中所罗列的任何特殊说明


### 接口隔离原则（ISP）

客户端不应该强迫依赖它不需要的接口

- 一组接口集合：如果部分接口只被部分调用者使用，就需要将这部分接口隔离出来，单独给这部分调用者使用
- 单个API接口或函数：部分调用者只需要函数中部分功能，我们就需要把函数拆分为粒度更细的多个函数
- OOP中接口：接口设计尽量单一，不要让接口实现类或调用者，依赖不需要接口函数


接口隔离侧重于接口设计，单一职责针对模块，类，接口设计。


### **SRP和ISP区别**

单一职责通过对模块，类，接口的设计；而接口隔离更倾向于接口设计，判断依据是通过调用者如何使用接口间接判断（如果只是用部分接口，则接口设计不够单一）


### 

- 控制反转：笼统的设计思想，流程控制权从程序员反转给了框架
- 依赖注入：编码技巧，不通过new方式在类内部创建依赖类对象，通过在外部创建好后，通过构造函数，函数参数等方式传递给类来使用
- 依赖注入框架：通过依赖注入框架提供扩展点，简单配置所需类以及类与类之间依赖关系，自动创建对象，管理对象生命周期。
- 依赖反转：指导框架层面设计，高层模块不依赖低层模块，共同依赖同一个抽象。抽象不依赖具体细节，具体细节依赖抽象。


### KISS原则

simple and stupid 

KISS原则是保持代码可读性和可维护性重要手段。

- 不要使用大家可能都不懂的技术来实现代码
- 不要重复造轮子，善于使用已经有的工具类库
- 不要过度优化，为了非高频场景下的极致性能，优化代码

同样的代码，在某个业务场景下满足KISS，换一个场景可能就不满足了(平常使用的字符串匹配使用JDK提供函数就够了，而大数据量的字符串匹配使用KMP等算法更合适)

### YAGNI原则

不要去设计当前用不到的功能，不要做过度设计

### DRY原则

don`t Repeat Yourself 

- 实现逻辑重复，但功能语义不重复的代码，并不违反DRY原则；
- 实现逻辑不重复，但功能语义重复的代码，违反DRY原则；
- 代码执行重复也违反DRY原则


在评价要给设计原则是否合理时，要从实际场景加上**可读性，可复用性，可扩展性，可维护性出发**，单一职责根据不同场景，功能业务模块不同时期，以及不同维度有不同的解读。


### 高内聚
相近功能应该放到同一个类中

###  松耦合

类与类之间的依赖关系简单清晰，一个类的改动不会或较少影响依赖类的代码改动

**why**

松耦合，高类聚，控制代码复杂度

**when**

修改代码牵一发而动全身，模块与模块，类与类依赖关系是否复杂

**how**

封装，抽象，中间层，模块化，设计模式，依赖注入，接口隔离，。
 
- **迪米特法则**：基于接口编程，不该有直接依赖关系的类之间，不要有依赖。有依赖关系的类之间，尽量只依赖必要的接口。


## 重构

**why**

重构可以保持代码质量持续处于一个可控状态。

**what**

- 大规模高层次重构，代码分层，模块化，解耦，梳理类之间关系，抽象复用组件。
- 小规模低层次重构，规范命名，注释，函数改造，大类改造，代码复用，类，方法级别重构。

**when**

持续重构意识

**how**

设计模式，编码规范

### **编码规范**

**不友好代码**

- 代码中包含未决行为逻辑
- 滥用可变全局变量
- 滥用静态方法
- 使用复杂继承关系
- 高度耦合代码

**命名**

- 作用域小使用短名
- 作用域大使用长名
- 利用上下文简化命名
- 命名要可读，可搜索

**注释**

怎么写：做什么，为什么，怎么做


### 单元测试

对类和函数进行代码层面的测试，测试编写代码逻辑是否正确

**why**

有效发现bug和设计上的问题。

**how**

通过各种测试用例，覆盖各种输入，异常，边界情况

**代码可测试性**

针对代码编写单元测试的难易程度。

**编写可测试性代码的手段**

通过MOCK方法解决依赖外部服务问题



### **代码质量审查**

**常规checkList**

- 目录是否合理，模块划分是否清晰，代码结构是高内聚，松耦合
- SOLID,DRY,KISS,YAGNI,LOD 设计原则，设计思想
- 设计模式是否得当，是否过度
- 代码是否易扩展，是否可复用，是否有现成类库可用
- 代码是否容易测试，覆盖率
- 代码是否易读，编码规范，命名，注释等

**业务checkList**

- 代码是否实现预期业务需求
- 逻辑是否正常，各种异常是否处理成功
- 日志是否得当，是否方便追踪bug
- 接口是否易用，幂等，事务

单元测试用例怎么写，取决于你如何定义函数


### 程序错误返回

**返回错误码**

- 极少会用到，API对外三方接口可能会用到

**返回NULL**

- 数据不存在等非异常行为

**返回空对象**

- 函数返回对象时字符串/集合类型时，便于函数调用不用做NULL值判断

**抛出异常对象**

- 常用函数出错返回数据类型，


**函数异常的处理**

- 吞掉，下层函数不用关心上层调用的此次异常
- 原封不同抛出，上层调用关心，理解此次异常
- 包装成其他异常抛出，上层调用不理解，包装成新的理解的异常


Spring中的设计思想

- 约定大于配置：以一定的规范去约定配置方式，既不牺牲配置灵活性，又节省了大量编写配置的时间，，提高了开发
效率
- 低侵入，松耦合：IOC,AOP提供无侵入的注入bean和一些其他非业务的功能
- 模块化，轻量级：使用分层，模块化划分不同功能，仅有上层依赖下层，用户自定义引入所需模块
- 再封装，再抽象：对于其他中间件，驱动等多种实现进行封装，提供统一等调用接口


## **代码复用性**

如果当下没有复用的需求，未来复用需求也不明确，就暂时不需要考虑代码复用性。

### **代码复用性提高**

- 减少代码耦合，耦合性代码在抽离的时候会影响到其他相关代码
- 满足单一职责，大而全的模块，类，相互之间依赖就会很严重，增加代码耦合。
- 模块化，类，函数模块化利于搭积木式的复用
- 业务逻辑和非业务逻辑分离，业务无关的代码更容易抽取成类库，组件，利于复用
- 通用代码下沉，严格层级的调用
- 继承，抽象，封装，多态
- 应用模板等设计模式

### **什么时候代码应该复用**

Rule Of Three

同样的代码，在某个业务场景下满足KISS，换一个场景可能就不满足了(平常使用的字符串匹配使用JDK提供函数就够了，而大数据量的字符串匹配使用KMP等算法更合适)


## 分层

### **为什么要分层**

- 分层能起到代码复用的作用
- 分层能起到隔离变化作用
- 分层能提高代码可测试性
- 分层能应对系统复杂性
 